#!/usr/bin/env python
import xml.etree.ElementTree as ET
try:
    #Python3
    from urllib.request import urlopen, urlretrieve
except:
    #Python2
    from urllib import urlretrieve
    import urllib2
    def urlopen(url):
        request = urllib2.Request(url)
        return urllib2.urlopen(request)
import tarfile
import sys
import os.path
import xmltodict
import re
import argparse
from jinja2 import Environment, PackageLoader, select_autoescape, FileSystemLoader
from lxml.html import fromstring, tostring
import subprocess
import json
from datetime import datetime
from traceback import print_exc

setupconfigfilescript = '''
def writesetupconfig(**kwargs):
    import json
    setupconfig=dict()
    for k in kwargs.keys():
        try:
            #If it is JSON serializable
            dummy = json.dumps(kwargs[k])
            #Keep it
            setupconfig[k] = kwargs[k]
        except:
            #If not, don't keep it
            pass
    with open('{0}','w') as f:
        f.write(json.dumps(setupconfig))
'''

re_requiresplit = re.compile('([^<>=]*)([<>]?=.*)')
re_setupfile = re.compile('setup\s*\(')
re_setupimport = re.compile('^(\s*)(from\s+(setuptools|distutils.core)\s+import.*setup(,|$)|import\s+(setuptools|distutils.core))')

class pythonModuleException(Exception):
    pass

class python_module(dict):
    def __init__(self, *args, **kwargs):
        for arg in args:
            if isinstance(arg, dict):
                for k in arg:
                    self[k] = arg[k]
        for arg in kwargs:
            self[arg] = kwargs[arg]
        try:
            self.modulename = self['modulename']
        except KeyError:
            raise pythonModuleException('You didn\'t specify modulename')

    def version(self):
        try:
            version = self['version']
        except:
            version = None
        if not version:
            doap=self.get_doap()
            self['version'] = version = doap['release']['Version']['revision']
        return version

    def get_doap(self):
        try:
            doap = self['doap']
        except:
            doap = None
        if not doap:
            if 'version' in self:
                url="https://pypi.python.org/pypi?:action=doap&name={0}&version={1}".format(self['modulename'], self['version'])
            else:
                url="https://pypi.python.org/pypi?:action=doap&name={0}".format(self['modulename'])
            self['doapurl'] = url
            handler = urlopen(url)
            xmlkeyvals = xmltodict.parse(handler.read())
            doap = self['doap'] = xmlkeyvals['rdf:RDF']['Project']
        return doap

    def download_source(self):
        try:
            sourcepath=self['sourcepath']
        except:
            sourcepath=None
        if not sourcepath:
            url = self.downloadpage()
            source = self['source'] = os.path.basename(url)
            filename = source.split('#')[0]
            sourcepath = self['sourcepath'] = os.path.expanduser('~/rpmbuild/SOURCES/'+filename)
        if not os.path.exists(sourcepath):
            urlretrieve(url, sourcepath)
        return sourcepath

    def extract_source(self):
        sourcepath = self.download_source()
        try:
            extractedpath = self['extractedpath']
        except:
            extractedpath = None
        if not extractedpath:
            extractedpath = self['extractedpath'] = '/tmp/{0}-{1}'.format(self['modulename'], self.version())
        if not os.path.exists(extractedpath):
            tar = tarfile.open(sourcepath, mode='r:gz')
            tar.extractall(path="/tmp")
        return extractedpath

    def get_setupconfig(self):
        extractedpath = self.extract_source()
        setupconfigfilepath = '{0}/writesetupconfig.py'.format(extractedpath, self['modulename'])
        setupconfigjsonpath = '{0}/writesetupconfig.json'.format(extractedpath, self['modulename'])

        if not os.path.exists(setupconfigfilepath):
            setupfile = open('{0}/setup.py'.format(extractedpath), 'rb')
            setupconfigfile = open(setupconfigfilepath, 'w')
            for l in setupfile:
                l=l.decode('ascii', 'ignore')
                l = re_setupfile.sub('writesetupconfig(',l)
                setupconfigfile.write(l)
                m = re_setupimport.search(l)
                if m:
                    indent = m.group(1)
                    for scriptline in setupconfigfilescript.format(setupconfigjsonpath).split('\n'):
                        setupconfigfile.write(indent+scriptline+'\n')
            setupfile.close()
            setupconfigfile.close()

        if not os.path.exists(setupconfigjsonpath):
            writer = subprocess.Popen(['python', '{0}/writesetupconfig.py'.format(extractedpath)], cwd=extractedpath)
            writer.wait()

        if not 'setupconfig' in self:
            setupconfig = open(setupconfigjsonpath).read()
            if not len(setupconfig):
                raise pythonModuleException('Error getting setupconfig for {0} - {1}. {2} contains no data...'.format(self['modulename'], self.version(), setupconfigjsonpath))
            self['setupconfig'] = json.loads(open(setupconfigjsonpath).read())
        return self['setupconfig']

    def requires(self):
        config = self.get_setupconfig()
        try:
            return config['install_requires']
        except:
            return []
   
    def generate_spec(self, templatepath):
        doap = self.get_doap()
        config = self.get_setupconfig()
        if 'summary' not in self:
            self['summary'] = doap['shortdesc']
        try:
            self['description'] = description_sanitizer(config['long_description'])
        except KeyError:
            self['description'] = description_sanitizer(config['description'])
        self['spec'] = os.path.expanduser('~/rpmbuild/SPECS/{0}-{1}.spec'.format(self['modulename'], self.version()))
        self['date'] = datetime.now().strftime('%a %b %-d %Y')
        self['license'] = config['license']
        self['template'] = templatepath
    
        if not os.path.exists(self['spec']):
            templatedir = os.path.dirname(templatepath)
            templatefile = os.path.basename(templatepath)
            env = Environment(
                loader = FileSystemLoader(templatedir),
                autoescape=select_autoescape(['html', 'xml'])
            )
            template = env.get_template(templatefile)
            spec=open(self['spec'], 'w')
            spec.write(template.render(self))
            spec.close()

    def module_versions(self):
        try:
            versions = self['versions']
        except:
            versions = None
        if not versions:
            self['versionsurl'] = url = 'https://pypi.org/project/{0}/#history'.format(self['modulename'])
            handler = urlopen(url)
            root = fromstring(handler.read())
            versions = self['versions'] = []
            for div in sroot.find_class("release__version"):
                for l in div.iterlinks():
                    versions.append(l[0].text)
        for v in versions:
            yield(v)
    
    def downloadpage(self):
        try:
            sourceurl = self['sourceurl']
        except:
            sourceurl = None

        if not sourceurl:
            dlpageurl = 'https://pypi.python.org/pypi/{0}/{1}'.format(self['modulename'], self.version())
            dlpagehandler = urlopen(dlpageurl)
            dlpageroot = fromstring(dlpagehandler.read())
            tablerows = dlpageroot.xpath("//tr")
            for tr in tablerows:
                try:
                    tablecols = tr.xpath("td")
                    dlurl = tablecols[0].xpath("span/a")[0].attrib['href']
                    dltype = tablecols[1].text.strip()
                    if dltype == 'Source':
                        sourceurl = self['sourceurl'] = dlurl
                        break
                except:
                    pass
        if not sourceurl:
            raise pythonModuleException('Could not detect source url')
        return sourceurl
    
def description_sanitizer(desc):
    desc=desc.encode('ascii', 'ignore').decode()
    tag_re = re.compile(':[a-z]+:')
    empty_re = re.compile('^\s*$')
    empty_count = 0
    ret = []
    for l in desc.split('\n'):
        if '-----' in l:
            ret = ret[:-1]
            break
        elif '>>>' in l:
            pass
        elif '===' in l:
            pass
        elif '::' in l:
            pass
        elif tag_re.search(l):
            pass
        elif empty_re.search(l):
            empty_count += 1
            if empty_count == 1:
                ret.append(l)
        else:
            empty_count = 0
            ret.append(l)
    return '\n'.join(ret)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate a spec file for a python module')
    parser.add_argument('-p', '--package', required=True, help='The python package to generate a spec for')
    parser.add_argument('-v', '--version', default=None, help='the version of the module to build a spec for')
    parser.add_argument('-t', '--template', default='./templates/spec.jinja2', help='the jinja2 template to use')
    parser.add_argument('-n', '--buildername', default='J. Doe', help='the name of the person who is building')
    parser.add_argument('-e', '--buildermail', default='jdoe@example.com', help='the jinja2 template to use')
    
    options = parser.parse_args()
    for subdir in [ 'SPECS', 'SOURCES' ]:
        d = os.path.expanduser(os.path.join('~/rpmbuild', subdir))
        if not os.path.exists(d):
            os.makedirs(d, mode=0o750)
    
    template = os.path.abspath(os.path.expanduser(options.template))
    
    modargs = {'modulename': options.package, 'buildername': options.buildername, 'buildermail': options.buildermail}
    if options.version:
        modargs['version'] = options.version
    
    try:
        mod = python_module(modargs)
        mod.generate_spec(options.template)
    except:
        print('Error while building module', options)
        print_exc()
