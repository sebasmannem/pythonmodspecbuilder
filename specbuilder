#!/usr/bin/env python
import xml.etree.ElementTree as ET
try:
    #Python3
    from urllib.request import urlopen, urlretrieve
except:
    #Python2
    from urllib import urlretrieve
    import urllib2
    def urlopen(url):
        request = urllib2.Request(url)
        return urllib2.urlopen(request)
import tarfile
import zipfile
import sys
import os
import xmltodict
import re
import argparse
from jinja2 import Environment, PackageLoader, select_autoescape, FileSystemLoader
from lxml.html import fromstring, tostring
import subprocess
import json
from datetime import datetime
from traceback import print_exc

setupconfigfilescript = '''
def writesetupconfig(**kwargs):
    import json
    setupconfig=dict()
    for k in kwargs.keys():
        try:
            #If it is JSON serializable
            dummy = json.dumps(kwargs[k])
            #Keep it
            setupconfig[k] = kwargs[k]
        except:
            #If not, don't keep it
            pass
    with open('{0}','w') as f:
        f.write(json.dumps(setupconfig))
'''

re_requiresplit = re.compile('^([^<>=!]*)([<>=!]+.*)')
re_limit = re.compile('([<>=!]+) *(\S*)')
re_setupfile = re.compile('(setuptools\.)?setup\s*\(')
re_setupimport = re.compile('^(\s*)(from\s+(setuptools|distutils.core)\s+import.*setup(,|$)|import\s+(setuptools|distutils.core))')

class pythonModuleException(Exception):
    pass

class python_module(dict):
    members = {}
    def __init__(self, *args, **kwargs):
        for arg in args:
            if isinstance(arg, dict):
                for k in arg:
                    self[k] = arg[k]
        for arg in kwargs:
            self[arg] = kwargs[arg]
        try:
            self.modulename = self['modulename']
        except KeyError:
            raise pythonModuleException('You didn\'t specify modulename')
        try:
            self.verbosity = int(self['verbosity'])
        except:
            self.verbosity = 0
        version = self.version()
        try:
            self.__class__.members[self.modulename].add(version)
        except:
            self.__class__.members[self.modulename] = set([self.version()])
        if not 'release' in self:
            self['release'] = '1%{?dist}'

    def version(self):
        try:
            version = self['version']
        except:
            version = None
        if not version:
            doap=self.get_doap()
            self['version'] = version = doap['release']['Version']['revision']
        return version

    def get_doap(self):
        try:
            doap = self['doap']
        except:
            doap = None
        if not doap:
            self.print_msg(2, 'Downloading doap record')
            if 'version' in self:
                url="https://pypi.python.org/pypi?:action=doap&name={0}&version={1}".format(self.modulename, self['version'])
            else:
                url="https://pypi.python.org/pypi?:action=doap&name={0}".format(self.modulename)
            self['doapurl'] = url
            handler = urlopen(url)
            xmlkeyvals = xmltodict.parse(handler.read())
            doap = self['doap'] = xmlkeyvals['rdf:RDF']['Project']
        return doap

    def download_source(self):
        try:
            sourcepath=self['sourcepath']
        except:
            sourcepath=None
        if not sourcepath:
            url = self.downloadpage()
            source = self['source'] = os.path.basename(url)
            filename = source.split('#')[0]
            sourcepath = self['sourcepath'] = os.path.expanduser('~/rpmbuild/SOURCES/'+filename)
        if not os.path.exists(sourcepath):
            self.print_msg(1, 'Downloading sources')
            urlretrieve(url, sourcepath)
        return sourcepath

    def extract_source(self):
        sourcepath = self.download_source()
        try:
            extractedpath = self['extractedpath']
        except:
            extractedpath = None
        if not extractedpath:
            extractedpath = self['extractedpath'] = '/tmp/{0}-{1}'.format(self.modulename, self.version())
        if not os.path.exists(extractedpath):
            try:
                file_name_parts = os.path.basename(sourcepath).split('.')
                file_extension = '.'.join(file_name_parts[1:])
                file_extension_lower = file_extension.lower()
                if file_extension_lower.endswith('tar.gz') or file_extension_lower.endswith('tgz'):
                    archive = tarfile.open(sourcepath, mode='r:gz')
                elif file_extension_lower.endswith('tar'):
                    archive = tarfile.open(sourcepath, mode='r')
                elif file_extension_lower.endswith('zip'):
                    archive = zipfile.ZipFile(sourcepath, mode='r')
                else:
                    print(file_extension_lower)
                    raise pythonModuleException('Cannot extract {0} (unknown extension)'.format(sourcepath))
                self.print_msg(1, 'Extracting sources from {0}'.format(sourcepath))
                archive.extractall(path="/tmp")
            except:
                print('Error extracting {0}'.format(extractedpath))
                raise
        return extractedpath

    def get_setupconfig(self):
        extractedpath = self.extract_source()
        setupconfigfilepath = '{0}/writesetupconfig.py'.format(extractedpath, self.modulename)
        setupconfigjsonpath = '{0}/writesetupconfig.json'.format(extractedpath, self.modulename)

        if not os.path.exists(setupconfigfilepath):
            self.print_msg(2, 'Converting setup.py to writesetupconfig.py')
            setupfile = open('{0}/setup.py'.format(extractedpath), 'rb')
            setupconfigfile = open(setupconfigfilepath, 'w')
            for l in setupfile:
                l=l.decode('ascii', 'ignore')
                l = re_setupfile.sub('writesetupconfig(',l)
                setupconfigfile.write(l)
                m = re_setupimport.search(l.rstrip())
                if m:
                    indent = m.group(1)
                    for scriptline in setupconfigfilescript.format(setupconfigjsonpath).split('\n'):
                        setupconfigfile.write(indent+scriptline+'\n')
            setupfile.close()
            setupconfigfile.close()

        if not os.path.exists(setupconfigjsonpath):
            self.print_msg(2, 'Running writesetupconfig.py')
            writer = subprocess.Popen(['python', '{0}/writesetupconfig.py'.format(extractedpath)], cwd=extractedpath)
            writer.wait()

        if not 'setupconfig' in self:
            self.print_msg(3, 'Reading setupconfig.json')
            setupconfig = open(setupconfigjsonpath).read()
            if not len(setupconfig):
                raise pythonModuleException('Error getting setupconfig for {0} - {1}. {2} contains no data...'.format(self.modulename, self.version(), setupconfigjsonpath))
            self['setupconfig'] = json.loads(open(setupconfigjsonpath).read())
        return self['setupconfig']

    def requires(self):
        self.print_msg(3, 'Detecting requires')
        extractedpath = self.extract_source()
        config = self.get_setupconfig()
        ret = {}
        for require in ['install_requires']:
            self.print_msg(3, 'Detecting '+require)
            if require in config.keys():
                for requirement in config[require]:
                    try:
                        requiresplitmatch = re_requiresplit.match(requirement)
                        if requiresplitmatch:
                            name  = requiresplitmatch.group(1)
                            versions = []
                            for v in requiresplitmatch.group(2).split(','):
                                if '!=' in v:
                                    #!= isn't supported by rpmbuild. skip it.
                                    pass
                                else:
                                    limit_matches = re_limit.match(v).groups()
                                    versions.append('{0} {1}'.format(*limit_matches))
                        else:
                            name = requirement
                            versions = []
                        ret[name.strip()] = versions
                    except Exception as e:
                        pass
        try:
            requiresfilepath = os.path.join(extractedpath, self.modulename.replace('-', '_')+'.egg-info', 'requires.txt')
            with open(requiresfilepath) as requiresfile:
                self.print_msg(3, 'Reading requires from '+requiresfilepath)
                for line in requiresfile:
                    if '[' in line:
                        continue
                    line = line.strip()
                    m = re_requiresplit.match(line)
                    if m:
                        name  = m.group(1)
                        versions = m.group(2).split(',')
                        versions = [ '{0} {1}'.format(*(re_limit.match(v).groups())) for v in versions ]
                    else:
                        name = line
                        versions = []
                    name = name.strip()
                    if name:
                        ret[name.strip()] = versions
        except Exception as e:
            pass
        for k in ret:
            yield (k, ret[k])

    def print_msg(self, verbosity, msg):
        if verbosity <= self.verbosity:
            print('{0}: {1}'.format(self.modulename, msg))

    def generate_spec(self, templatepath=None):
        doap = self.get_doap()
        config = self.get_setupconfig()
        self.print_msg(2, 'Detecting jinja variables from setupconfig')
        if 'summary' not in self:
            self['summary'] = doap['shortdesc']
        if 'long_description' in config.keys():
            self['description'] = description_sanitizer(config['long_description'])
        elif 'description' in config.keys():
            self['description'] = description_sanitizer(config['description'])
        else:
            self['description'] = ''
        self['spec'] = os.path.expanduser('~/rpmbuild/SPECS/{0}-{1}.spec'.format(self.modulename, self.version()))
        self['date'] = datetime.now().strftime('%a %b %-d %Y')
        try:
           self['license'] = config['license']
        except:
           self['license'] = ''
        if not templatepath:
            try:
                templatepath = self['template']
            except:
                raise pythonModuleException('Please specify a jinja template to generate spec from.')
        self['requires'] = self.requires()
        if not 'buildfilelist' in self:
            self['buildfilelist'] = buildfilelist = set()
            buildfilelist.add('%exclude %{python3_sitelib}/%{modname}-%{version}-py%{python3_version}.egg-info')
            buildfilelist.add('%{python3_sitelib}/%{modname}')

        if not os.path.exists(self['spec']):
            self.print_msg(1, 'Creating spec from template')
            templatedir = os.path.dirname(templatepath)
            templatefile = os.path.basename(templatepath)
            env = Environment(loader = FileSystemLoader(templatedir), autoescape=select_autoescape(['html', 'xml']))
            template = env.get_template(templatefile)
            spec=open(self['spec'], 'w')
            spec.write(template.render(self))
            spec.close()
            self['spec_generated'] = True
        elif not 'spec_generated' in self:
            self['spec_generated'] = False

    def module_versions(self):
        try:
            versions = self['versions']
        except:
            versions = None
        if not versions:
            self.print_msg(3, 'Detecting all available versions')
            self['versionsurl'] = url = 'https://pypi.org/project/{0}/#history'.format(self.modulename)
            handler = urlopen(url)
            root = fromstring(handler.read())
            versions = self['versions'] = []
            for div in sroot.find_class("release__version"):
                for l in div.iterlinks():
                    versions.append(l[0].text)
        for v in versions:
            yield(v)

    def downloadpage(self):
        try:
            sourceurl = self['sourceurl']
        except:
            sourceurl = None

        if not sourceurl:
            self.print_msg(3, 'Detecting download page')
            dlpageurl = 'https://pypi.python.org/pypi/{0}/{1}'.format(self.modulename, self.version())
            dlpagehandler = urlopen(dlpageurl)
            dlpageroot = fromstring(dlpagehandler.read())
            tablerows = dlpageroot.xpath("//tr")
            for tr in tablerows:
                try:
                    tablecols = tr.xpath("td")
                    dlurl = tablecols[0].xpath("span/a")[0].attrib['href']
                    dltype = tablecols[1].text.strip()
                    if dltype == 'Source':
                        sourceurl = self['sourceurl'] = dlurl
                        break
                except:
                    pass
        if not sourceurl:
            raise pythonModuleException('Could not detect source url')
        return sourceurl

    def rpmvalue(self, key):
        out, err = subprocess.Popen(['rpm', '-E', key], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
        return out.decode().strip()

    def release(self):
        return self.rpmvalue(self['release'])

    def arch(self):
        try:
            return self['buildarch']
        except:
            return 'noarch'

    def buildroot(self):
        try:
            return self['buildroot']
        except:
            return os.path.expanduser('~/rpmbuild/BUILDROOT/{0}-{1}.{3}'.format(self.modulename, self.version(), self.release(), self.arch()))

    def createbuildfilelist(self):
        buildroot = self.buildroot()
        buildrootlen = len(buildroot)
        buildfilelist = set()
        replacers = {}
        for rpmval in ['%{python3_sitelib}', '%{python3_sitearch}', '%{python_sitelib}', '%{python_sitearch}', '%{_bindir}', '%{_libdir}']:
            path = self.rpmvalue(rpmval)
            replacers[path] = rpmval
        sortedreplacers = sorted(replacers.keys(), key=len)
        for dirname, subdirs, files in os.walk(buildroot):
            dirname = dirname[buildrootlen:]
            for replacer in sortedreplacers:
                if dirname.startswith(replacer):
                    dirname = replacers[replacer]+dirname[len(replacer):]
            if not dirname:
                dirname = '/'
            if not dirname[-1] == '/':
                dirname += '/'
            if '__pycache__' in dirname:
                dirname = dirname.split('__pycache__')[0] + '__pycache__'
                buildfilelist.add(dirname)
            else:
                for filename in files:
                    filefullpath = dirname + filename
                    if filename.endswith('.egg-info'):
                        filefullpath ='%exclude ' + filefullpath
                    buildfilelist.add(filefullpath)
        if len(buildfilelist.symmetric_difference(self['buildfilelist'])) > 0:
            self['buildfilelist'] = buildfilelist
            return True
        else:
            return False

    def build(self):
        if not 'spec' in self:
            self.generate_spec()
        buildroot = self.buildroot()
        out, err = subprocess.Popen(['rpmspec', '--query', self['spec']], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()
        rpmlist = out.splitlines()
        if len(rpmlist):
            done = True
            for rpm in rpmlist:
                rpmfile = os.path.expanduser('~/rpmbuild/RPMS/noarch/{0}.rpm'.format(rpm))
                if os.path.exists(rpmfile):
                    pass
                elif os.path.exists(rpmfile.replace('noarch', 'x86_64')):
                    pass
                else:
                    done = False
                    break
            if done:
                return
        self.print_msg(1, 'Building rpm.')
        if self.verbosity >= 4:
            redirect = None
        else:
            redirect = open(os.devnull, 'w')
        for stage in ['p', 'c', 'i', 'l', 'a']:
            try:
                subprocess.check_call(['rpmbuild', '--short-circuit', '--buildroot={0}'.format(buildroot), '-b'+stage, self['spec']], stdout=redirect, stderr=redirect)
                if stage == 'a':
                    self.print_msg(0, 'Building rpm succesfully finished.'.format(stage))
            except Exception as e:
                if stage == 'i':
                   corrected = False
                   #In this stage, two things might be the issue: The architecture could be other than noarch and the %files section could be off.
                   corrected = self.createbuildfilelist()
                   if os.path.exists(os.path.join(buildroot, 'usr/lib64')) and self['spec_generated'] and self.arch() == 'noarch':
                       self['buildarch'] = 'x86_64'
                       corrected = True
                   if not corrected:
                       raise pythonModuleException('Building RPM Failed (no architecture change and no filelist change).')
                       break
                   os.unlink(self['spec'])
                   self.generate_spec()
                   try:
                       subprocess.check_call(['rpmbuild', '--buildroot={0}'.format(buildroot), '-bi', self['spec']], stdout=redirect, stderr=redirect)
                   except:
                       raise pythonModuleException('Building RPM Failed (even after architecture change and/or filelist change).')
                       break
                else:
                    self.print_msg(0, 'Building rpm FAILED in stage {}.'.format(stage))
                    self.print_msg(2, e)
                    break
        try:
            redirect.close()
        except:
            pass

class versionException(Exception):
    pass

class version(str):
    def cmp(self, other):
        try:
            myParts = self.split()
            hisParts = other.split()
            smallestlen = min(len(myParts), len(hisParts))
        except:
            raise versionException('''Seems {0} is'n a valuable component to compare to {1}'''.format(other.__repr__(), self.__repr__()))

        i = 0
        while True:
            try:
                mine = myParts[i]
            except KeyError:
                return -1
            try:
                his = hisParts[i]
            except KeyError:
                return -1
            mineisstr = isinstance(mine, str)
            hisisstr  = isinstance(his, str)
            if mineisstr != hisisstr:
                return cmp(mineisstr, hisisstr)
            else:
                comp = cmp(mine, his)
                if comp:
                    return comp
            i+=1
        return cmp(len(myParts), len(hisParts))

    def split(self):
        #Look at https://fedoraproject.org/wiki/Archive:Tools/RPM/VersionComparison for more info
        letter, digit, other = 'l', 'd', 'o'
        parts = []
        previous_type = None
        for c in self:
            if c >= 'a' and c <= 'z' or c >= 'A' and i <= 'Z':
                c_type = letter
            elif c >= '0' and c <= '9':
                c_type = digit
            else:
                c_type = other
            if not previous_type:
                #Processing first character
                if c_type in [ letter, digit ]:
                    part = c
                else:
                    #Seems to be that first character is not digit or letter.
                    #Thats interesting. Well, anyway, lets skip this one and test next character
                    continue
            elif previous_type == other and c_type == other:
                #Still in between parts
                pass
            elif previous_type == other:
                #New part
                part = c
            elif c_type == previous_type:
                #Current and previous characters are both letter or both digit
                part += c
            #elif c_type == other or c_type != previous_type:
            else:
                #end of part
                if previous_type == digit:
                    parts.append(int(part))
                else:
                    parts.append(part)
                if c_type != other:
                    part = c
                else:
                    part = ""
            previous_type = c_type
        if part:
            if previous_type == digit:
                parts.append(int(part))
            else:
                parts.append(part)
        return tuple(parts)

def description_sanitizer(desc):
    desc=desc.encode('ascii', 'ignore').decode()
    tag_re = re.compile(':[a-z]+:')
    empty_re = re.compile('^\s*$')
    empty_count = 0
    ret = []
    for l in desc.split('\n'):
        if '-----' in l:
            ret = ret[:-1]
            break
        elif '>>>' in l:
            pass
        elif '===' in l:
            pass
        elif '::' in l:
            pass
        elif tag_re.search(l):
            pass
        elif empty_re.search(l):
            empty_count += 1
            if empty_count == 1:
                ret.append(l)
        else:
            empty_count = 0
            ret.append(l)
    return '\n'.join(ret)

def download_modules_recursive(modulename, moduleversion = None, args={}):
    modargs = {}
    ret = {}
    for arg in args:
        modargs[arg] = args[arg]
    modargs['modulename'] = modulename
    if moduleversion:
        modargs['version'] = moduleversion
    if modulename in python_module.members:
        if moduleversion:
            if moduleversion in python_module.members:
               return ret
        else:
            return ret
    mod = python_module(modargs)
    if not moduleversion:
        moduleversion = mod.version()
    key = (modulename, moduleversion)
    ret[key] = mod
    for submodinfo in mod.requires():
        try:
            mods = download_modules_recursive(modulename = submodinfo[0], args = args)
            for k in mods:
                ret[k] = mods[k]
        except Exception as e:
            print ('Exception occurred while retrieving info on module {}'.format(submodinfo[0]))
    return ret

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate a spec file for a python module')
    parser.add_argument('-p', '--package', required=True, help='The python package to generate a spec for')
    parser.add_argument('-V', '--version', default=None, help='the version of the module to build a spec for')
    parser.add_argument('-v', '--verbose', action='count', help='the verbosity level (add multiple times for more verbosity)')
    parser.add_argument('-t', '--template', default='./templates/spec.jinja2', help='the jinja2 template to use')
    parser.add_argument('-n', '--buildername', default='J. Doe', help='the name of the person who is building')
    parser.add_argument('-e', '--buildermail', default='jdoe@example.com', help='the jinja2 template to use')
    parser.add_argument('-b', '--build', action='store_true', help='Actually try to build the rpm')

    options = parser.parse_args()
    for subdir in [ 'SPECS', 'SOURCES' ]:
        d = os.path.expanduser(os.path.join('~/rpmbuild', subdir))
        if not os.path.exists(d):
            os.makedirs(d, mode=0o750)

    template = os.path.abspath(os.path.expanduser(options.template))

    modargs = { 'buildername': options.buildername, 'buildermail': options.buildermail, 'template': template, 'verbosity': options.verbose }
    version = options.version

    mods = download_modules_recursive(options.package, version, modargs)
    for k in mods:
        try:
            mods[k].generate_spec()
            if options.build:
                mods[k].build()
        except:
            print('Error while building module', k)
            print_exc()
